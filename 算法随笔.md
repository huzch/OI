# 算法随笔

## 易错

1. 从1开始的下标，在取模后要再加1补正
1. 必须先排序再去重（因为去重要求有序数组）
1. 若空间特别大（达到1e8），多组测试数据清空时不能用memset（会超时），改成手动清空（用了多少清空多少）
1. 在读入图时，注意处理重边he

## 技巧

1. 处理环形问题，倍增/复写
2. 反向建图
3. 负数取模，补正，模加模，`((num % MOD) + MOD) %MOD`
4. 让字符串下标从1开始，`s = " " + s`



## 数据结构

### 单调栈

单调栈的作用：查找某元素左右最近的最大最小值（共四种）

```c++
//右边距离最近的最大值 --- 单调递减栈
for(int i=n; i>=1; --i) {
    while(st.size() && a[st.top()] <= a[i]) st.pop();
    if(st.size()) ret[i] = st.top();
    st.push(i);
}
```

单调栈中存储的是元素的下标



### 单调队列

单调队列的作用：查找窗口内最大最小值（共两种）

```c++
deque<int> q; //存下标
//窗口内最小值 --- 单调递增队列
for(int i=1; i<=n; ++i) {
    while(q.size() && a[q.back()] >= a[i]) q.pop_back();
    q.push_back(i);
    if(q.back() - q.front() + 1 > k) q.pop_front();
    if(i >= k) cout << a[q.front()] << " ";
}
```

单调队列中存储的是元素的下标

单调队列用双端队列deque实现，队头存储最大最小值



### 并查集

并查集的作用：处理合并、连通、传递等相关问题

#### 普通并查集

核心操作：查找

```c++
int find(int x) {
	return x == fa[x] ? x : fa[x] = find(fa[x]);
}
```

细节：`fa[x] = find(fa[x])`为路径压缩的优化

---

并查集一定要记得**初始化**！

```c++
for(int i=1; i<=n; ++i) fa[i] = i;
```

#### 扩展域并查集

普通并查集关系只有一种，而扩展域并查集关系有多种

关系有几种，fa数组就扩大几倍（记得也要全部初始化）

除了最开始的n个空间，后续扩大的空间是用来辅助的

#### 带权并查集

带权并查集更加灵活，利用权值维护集合中的相互关系，权值意义的设定因题而异

权值表示当前节点和父节点的某种关系（经典模型为距离）

查找与合并时，由于树结构变化，所以要更新结点权值

```c++
const int N = 1e5 + 10;
int fa[N], d[N]; //权值表示当前结点与父结点的距离

int find(int x) {
    if(fa[x] == x) return x;
    int t = find(fa[x]);
    d[x] += d[fa[x]];
    return fa[x] = t;
}

void un(int x, int y, int w) {
    int fx = find(x), fy = find(y);
    if(fx != fy) {
        d[fx] = d[fy] + w - d[x];
        fa[fx] = fy;
	}
}
```

---

**个人感觉**扩展域并查集比带权并查集容易理解和实现，扩展域并查集是为每个关系扩展出一个并查集（本质上有多个并查集），而带权并查集是为每个关系定义一种权值状态（本质只有一个并查集），有点类似于动态规划



### 字符串哈希

字符串哈希的作用：将字符串映射为一个p进制数（p一般取131或13331）

数据类型为ULL（unsigned long long），可以自动模M（一个较大的数）

若求子串，常采用前缀哈希

```c++
typedef unsigned long long ULL;
const int N = 1e5 + 10;
const int P = 13331;
ULL f[N], p[N];
string s; //下标从1开始

void init_hash() {
    p[0] = 1; //P的0次方为1
    for(int i=1; i<=s.size(); ++i) {
        f[i] = f[i - 1] * P + s[i];
        p[i] = p[i - 1] * P;
    }
}

ULL get_hash(int l, int r) {
    return f[r] - f[l - 1] * p[r - l + 1];
}
```



### 字典树

字典树的作用：快速查询某个字符串**是多少个字符串的前缀**，以及某个字符串的**出现次数**等相关问题

在字典树中，边存储字符，结点无实际意义

为了查询**前缀**和**出现次数**，要维护每个结点的pass和end属性

- pass：经过该结点的次数
- end：以该结点为结尾的字符串的个数

```c++
const int N = 1e6 + 10; //字符串的总长度
int tr[N][62], p[N], e[N]; //小写字母+大写字母+数字，所以长度为26+26+10=62
int id; //记录结点数

int get_num(char ch) {
    if(islower(ch)) return ch - 'a';
    if(isupper(ch)) return ch - 'A' + 26;
    if(isdigit(ch)) return ch - '0' + 52;
}

void insert(string& s) {
    int cur = 0; //从根结点开始
    ++p[cur];
    
    for(char ch: s) {
        int path = get_num(ch);
        if(tr[cur][path] == 0) tr[cur][path] = ++id;
        cur = tr[cur][path];
        ++p[cur];
    }
    
    ++e[cur];
}

int find(string& s) {
    int cur = 0;
    
    for(char ch: s) {
        int path = get_num(ch);
        if(tr[cur][path] == 0) return 0;
        cur = tr[cur][path];
    }
    
    return e[cur];
}

int find_pre(string& s) {
    int cur = 0;
    
    for(char ch: s) {
        int path = get_num(ch);
        if(tr[cur][path] == 0) return 0;
        cur = tr[cur][path];
    }
    
    return p[cur];
}
```



## 动态规划

### 背包DP

状态转移方程：分类讨论最后一步

限定条件有3种问法：

1. 体积至多为V，最大价值（初始化为0）
2. 体积恰好为V，最大价值（首格为1，其余为负无穷）
3. 体积至少为V，最小价值（首格为1，其余为正无穷）

若求最值，状态转移方程为max或min；若求方案数，状态转移方程为+

---

以下默认为体积至多为V，最大价值

#### 01 背包

物品可选1次

状态表示：`f[i][j]`：在前i个物品中挑选，体积至多为j时，所选的最大价值

状态转移方程：

- 不选第i个物品：`f[i-1][j]`
- 选第i个物品：`f[i-1][j-v[i]] + w[i]`

双重循环

空间优化：从大到小

```c++
for(int i=1; i<=n; ++i) {
    for(int j=V; j>=v[i]; --j) {
        f[j] = max(f[j], f[j-v[i]] + w[i]);
    }
}
```

#### 完全背包

物品可选无穷次

状态表示：`f[i][j]`：在前i个物品中挑选，体积至多为j时，所选的最大价值

状态转移方程：

- 不选第i个物品：`f[i-1][j]`
- 选第i个物品：`f[i][j-v[i]] + w[i]`（利用数学推导浓缩，选1个，选2个，...）

双重循环

空间优化：从小到大

```c++
for(int i=1; i<=n; ++i) {
    for(int j=v[i]; j<=V; ++j) {
        f[j] = max(f[j], f[j-v[i]] + w[i]);
    }
}
```

#### 多重背包

物品可选指定次

状态表示：`f[i][j]`：在前i个物品中挑选，体积至多为j时，所选的最大价值

状态转移方程：

- 不选第i个物品：`f[i-1][j]`
- 选第i个物品：`f[i-1][j-k*v[i]] + k*w[i]`

三重循环（空间优化时内层循环k从1开始，排除不选情况，防止重复计算）

空间优化：从大到小

```c++
for(int i=1; i<=n; ++i) {
    for(int j=V; j>=0; --j) {
        for(int k=1; k<=x[i] && k*v[i]<=j; ++k) {
            f[j] = max(f[j], f[j-k*v[i]] + k*w[i]);
        }
    }
}
```

多重背包还有一种二进制优化，但是不能用于求方案数

#### 分组背包

讨论对象从单个物品变成组，一个组内有多个物品，每个组中只选1个

状态表示：`f[i][j]`：在前i组物品中挑选，体积至多为j时，所选的最大价值

状态转移方程：

- 不选第i组物品：`f[i-1][j]`
- 选第i组物品：`f[i-1][j-a[i][k].v] + a[i][k].w`

三重循环

空间优化：从大到小

```c++
for(int i=1; i<=n; ++i) {
    for(int j=V; j>=0; --j) {
        for(int k=1; k<=x[i] && a[i][k].v<=j; ++k) {
            f[j] = max(f[j], f[j-a[i][k].v] + a[i][k].w);
        }
    }
}
```

#### 混合背包

将01背包、完全背包、多重背包混合

分类讨论即可

#### 多维费用背包

限制条件不止体积一个，有多个限制条件

在状态表示增加维数即可（注意空间优化）

### 区间DP

利用之前枚举横纵坐标的填表方式比较麻烦（从下往上，从左往右），所以用一种独属于区间DP的填表方式

- 先枚举区间长度，再枚举区间左端点
- 因为len为1时被初始化了，所以len从2开始

状态转移方程：

1. 分类讨论区间左右端点
2. 在区间中取一个分割点，将区间分割成两部分进行讨论



## 图论

### 拓扑排序

应用场景：**有向无环图**

原理：不断将入度为0的点加入队列

判断环：进行一次拓扑排序，若有结点未入队，则存在环

**拓扑排序**通常与**动态规划**一起考察，因为动态规划本质上每个状态之间的关系也是有向无环图，动态规划的填表顺序就是拓扑排序的遍历顺序

在拓扑排序中做动态规划，结果是分批次更新出来的（而不是一次更新出来）

### 单源最短路

堆优化的dijkstra算法

- st数组：标记哪些结点已经确定最短路

bellman-ford算法

- 每次松弛的起始点u，若dist[u]为正无穷，直接continue跳过，避免dist[u]+w溢出成负数

spfa算法

- st数组：标记哪些结点处于队列中
- 每次只将松弛点出边的点加入队列，则不会发生上述dist[u]为正无穷的现象

### 多源最短路

floyd算法，又称插点法，通过**不断加点作为桥梁**，来更新任意两点之间的最短路，本质是**动态规划**

状态表示：`f[k][i][j]`：经过前k个点，从i到j的最短距离

状态转移方程：

- 不选第k个点经过：`f[k-1][i][j]`
- 选第k个点经过：`f[k-1][i][k] + f[k-1][k][j]`

空间优化：`f[i][j] = min(f[i][j], f[i][k] + f[k][j])`

使用邻接矩阵存储即可

floyd算法是逐步更新，所以其中间状态也是有意义的，表示经过某些点能够到达的最短路

## 数学

### 数论

#### 最大公约数与最小公倍数

可利用最大公约数求最小公倍数：`gcd(a, b) * lcm(a, b) = a * b`

欧几里得算法，又称辗转相除法

```c++
LL gcd(LL a, LL b) {
    return b == 0 ? a : gcd(b, a % b);
}
```



### 组合数学

### 线性代数

### 博弈论

